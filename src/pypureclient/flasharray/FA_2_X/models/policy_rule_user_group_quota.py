# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 2.X
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re

import six
import typing

from ....properties import Property
if typing.TYPE_CHECKING:
    from pypureclient.flasharray.FA_2_X import models

class PolicyRuleUserGroupQuota(object):
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'context': 'FixedReferenceWithType',
        'destroyed': 'bool',
        'enforced': 'bool',
        'name': 'str',
        'notifications': 'list[str]',
        'policy': 'FixedReferenceWithType',
        'quota_limit': 'int',
        'quota_type': 'str',
        'subject': 'PolicyRuleUserGroupQuotaSubject',
        'time_remaining': 'int'
    }

    attribute_map = {
        'context': 'context',
        'destroyed': 'destroyed',
        'enforced': 'enforced',
        'name': 'name',
        'notifications': 'notifications',
        'policy': 'policy',
        'quota_limit': 'quota_limit',
        'quota_type': 'quota_type',
        'subject': 'subject',
        'time_remaining': 'time_remaining'
    }

    required_args = {
    }

    def __init__(
        self,
        context=None,  # type: models.FixedReferenceWithType
        destroyed=None,  # type: bool
        enforced=None,  # type: bool
        name=None,  # type: str
        notifications=None,  # type: List[str]
        policy=None,  # type: models.FixedReferenceWithType
        quota_limit=None,  # type: int
        quota_type=None,  # type: str
        subject=None,  # type: models.PolicyRuleUserGroupQuotaSubject
        time_remaining=None,  # type: int
    ):
        """
        Keyword args:
            context (FixedReferenceWithType): The context in which the operation was performed. Valid values include a reference to any array which is a member of the same fleet.  Other parameters provided with the request, such as names of volumes or snapshots, are resolved relative to the provided `context`. 
            destroyed (bool): Returns a value of `true` if the pod containing the user-group-quota policy rule has been destroyed and is pending eradication. The `time_remaining` value displays the amount of time left until the destroyed policy is permanently eradicated. Once the `time_remaining` period has elapsed, the user-group-quota policy rule is permanently eradicated and can no longer be recovered. 
            enforced (bool): Specifies whether the user-group-quota rule is enforced or unenforced. If the user-group-quota rule is enforced and user/group space usage exceeds the quota limit, any modification operations that result in a need for more space are blocked. If the quota rule is unenforced and logical space usage exceeds the quota limit, notification emails are sent to targets that are specified using the `notification` parameter. No client operations are blocked when an unenforced limit is exceeded. If set to `true`, the limit is enforced. If set to `false`, the quota limit is enforced. 
            name (str): Name of this rule. The name is automatically generated by the system. 
            notifications (list[str]): Specifies the targets to notify when usage approaches or exceeds the quota limit. Empty specifies that no targets will be notified. The `account` value specifies that the user or group owning the usage will be notified. 
            policy (FixedReferenceWithType): The policy to which this rule belongs.
            quota_limit (int): Logical space limit of the quota assigned by the rule, measured in bytes. The value cannot be negative. 
            quota_type (str): Specifies the type of quota rule. Valid values are `user-default`, `user`, `user-group-member`, `group-default` and `group`. Every user-group-quota rule has a rule type, and this field is always populated. 
            subject (PolicyRuleUserGroupQuotaSubject): The rule subject, when required. Rules of type `user`, `user-group-member` and `group` require a subject, specifying the user or group the rule is applicable to. 
            time_remaining (int): The amount of time left, in milliseconds, until the destroyed user-group-quota policy rule is permanently eradicated. 
        """
        if context is not None:
            self.context = context
        if destroyed is not None:
            self.destroyed = destroyed
        if enforced is not None:
            self.enforced = enforced
        if name is not None:
            self.name = name
        if notifications is not None:
            self.notifications = notifications
        if policy is not None:
            self.policy = policy
        if quota_limit is not None:
            self.quota_limit = quota_limit
        if quota_type is not None:
            self.quota_type = quota_type
        if subject is not None:
            self.subject = subject
        if time_remaining is not None:
            self.time_remaining = time_remaining

    def __setattr__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `PolicyRuleUserGroupQuota`".format(key))
        self.__dict__[key] = value

    def __getattribute__(self, item):
        value = object.__getattribute__(self, item)
        if isinstance(value, Property):
            raise AttributeError
        else:
            return value

    def __getitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `PolicyRuleUserGroupQuota`".format(key))
        return object.__getattribute__(self, key)

    def __setitem__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `PolicyRuleUserGroupQuota`".format(key))
        object.__setattr__(self, key, value)

    def __delitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `PolicyRuleUserGroupQuota`".format(key))
        object.__delattr__(self, key)

    def keys(self):
        return self.attribute_map.keys()

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            if hasattr(self, attr):
                value = getattr(self, attr)
                if isinstance(value, list):
                    result[attr] = list(map(
                        lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                        value
                    ))
                elif hasattr(value, "to_dict"):
                    result[attr] = value.to_dict()
                elif isinstance(value, dict):
                    result[attr] = dict(map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict") else item,
                        value.items()
                    ))
                else:
                    result[attr] = value
        if issubclass(PolicyRuleUserGroupQuota, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PolicyRuleUserGroupQuota):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
