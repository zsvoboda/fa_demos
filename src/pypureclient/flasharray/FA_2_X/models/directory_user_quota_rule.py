# coding: utf-8

"""
    FlashArray REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 2.X
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re

import six
import typing

from ....properties import Property
if typing.TYPE_CHECKING:
    from pypureclient.flasharray.FA_2_X import models

class DirectoryUserQuotaRule(object):
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'effectiveness': 'str',
        'enabled': 'bool',
        'enforced': 'bool',
        'policy': 'FixedReferenceWithType',
        'quota_limit': 'int',
        'quota_type': 'str',
        'rule_name': 'str',
        'subject': 'PolicyRuleUserGroupQuotaSubject'
    }

    attribute_map = {
        'effectiveness': 'effectiveness',
        'enabled': 'enabled',
        'enforced': 'enforced',
        'policy': 'policy',
        'quota_limit': 'quota_limit',
        'quota_type': 'quota_type',
        'rule_name': 'rule_name',
        'subject': 'subject'
    }

    required_args = {
    }

    def __init__(
        self,
        effectiveness=None,  # type: str
        enabled=None,  # type: bool
        enforced=None,  # type: bool
        policy=None,  # type: models.FixedReferenceWithType
        quota_limit=None,  # type: int
        quota_type=None,  # type: str
        rule_name=None,  # type: str
        subject=None,  # type: models.PolicyRuleUserGroupQuotaSubject
    ):
        """
        Keyword args:
            effectiveness (str): Describes whether the rule is the most effective rule that applies to the user. Possible values are `effective` and `ineffective_limit`. If the value is `effective` then the rule is the most effective rule for the user. If the value is `ineffective_limit` then there is at least one enforced rule with a lower quota limit that also applies to the user. As a result the quota limit of this rule is not the most effective. 
            enabled (bool): Where the user-group-quota policy is enabled. If `true` the rules in the policy impact the amount of usage the user can own in the managed directory. If `false` the rules in the policy do not have an effect. 
            enforced (bool): Whether the quota limit in the rule is enforced. If `true`, the user will be out of the allowed available space when usage reaches the quota limit. If `false`, the allowed usage may grow beyond the quota limit, but the user will be notified. 
            policy (FixedReferenceWithType): The user-group-quota policy with rules impacting the usage of the user. 
            quota_limit (int): The logical space limit assigned by the user-group-quota rule. 
            quota_type (str): The type of the user-group-quota rule. The `user-default`, `user` and `user-group-member` types impact the user. 
            rule_name (str): The unique name of the user-group-quota policy rule. 
            subject (PolicyRuleUserGroupQuotaSubject): The rule subject if the quota type is `user` or `user-group-member`. For `user` type, the subject matches the user impacted by the quota rule. For `user-group-member` type, the subject matches a group that the user is a member of. 
        """
        if effectiveness is not None:
            self.effectiveness = effectiveness
        if enabled is not None:
            self.enabled = enabled
        if enforced is not None:
            self.enforced = enforced
        if policy is not None:
            self.policy = policy
        if quota_limit is not None:
            self.quota_limit = quota_limit
        if quota_type is not None:
            self.quota_type = quota_type
        if rule_name is not None:
            self.rule_name = rule_name
        if subject is not None:
            self.subject = subject

    def __setattr__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DirectoryUserQuotaRule`".format(key))
        self.__dict__[key] = value

    def __getattribute__(self, item):
        value = object.__getattribute__(self, item)
        if isinstance(value, Property):
            raise AttributeError
        else:
            return value

    def __getitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DirectoryUserQuotaRule`".format(key))
        return object.__getattribute__(self, key)

    def __setitem__(self, key, value):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DirectoryUserQuotaRule`".format(key))
        object.__setattr__(self, key, value)

    def __delitem__(self, key):
        if key not in self.attribute_map:
            raise KeyError("Invalid key `{}` for `DirectoryUserQuotaRule`".format(key))
        object.__delattr__(self, key)

    def keys(self):
        return self.attribute_map.keys()

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            if hasattr(self, attr):
                value = getattr(self, attr)
                if isinstance(value, list):
                    result[attr] = list(map(
                        lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                        value
                    ))
                elif hasattr(value, "to_dict"):
                    result[attr] = value.to_dict()
                elif isinstance(value, dict):
                    result[attr] = dict(map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict") else item,
                        value.items()
                    ))
                else:
                    result[attr] = value
        if issubclass(DirectoryUserQuotaRule, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, DirectoryUserQuotaRule):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
